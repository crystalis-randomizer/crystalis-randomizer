import { Token } from './token.js';
const DEBUG = false;
export class Define {
    constructor(overloads) {
        this.overloads = overloads;
    }
    canOverload() {
        return this.overloads[this.overloads.length - 1].canOverload();
    }
    append(define) {
        if (!this.canOverload()) {
            const prevDef = this.overloads[this.overloads.length - 1].definition;
            const at = prevDef ? Token.at(prevDef) : '';
            const prev = at.replace(/at/, 'previously defined at');
            const nextDef = define.overloads[0].definition;
            const next = nextDef ? Token.nameAt(nextDef) : '';
            throw new Error(`Non-overloadable: ${next}${prev}`);
        }
        this.overloads.push(...define.overloads);
    }
    expand(tokens, start) {
        const reasons = [];
        for (const overload of this.overloads) {
            const result = overload.expand(tokens, start);
            if (Array.isArray(result))
                return result;
            reasons.push(result);
        }
        if (DEBUG)
            console.error(reasons.join('\n'));
        return undefined;
    }
    static from(macro) {
        var _a;
        if (!Token.eq(macro[0], Token.DEFINE))
            throw new Error(`invalid`);
        if (((_a = macro[1]) === null || _a === void 0 ? void 0 : _a.token) !== 'ident')
            throw new Error(`invalid`);
        const paramStart = macro[2];
        let overload;
        if (!paramStart) {
            overload = new TexStyleDefine([], [], macro[1]);
        }
        else if (paramStart.token === 'grp') {
            overload = new TexStyleDefine(paramStart.inner, macro.slice(3), macro[1]);
        }
        else if (paramStart.token === 'lp') {
            const paramEnd = Token.findBalanced(macro, 2);
            if (paramEnd < 0) {
                throw new Error(`Expected close paren ${Token.nameAt(macro[2])}`);
            }
            overload =
                new CStyleDefine(Token.identsFromCList(macro.slice(3, paramEnd)), macro.slice(paramEnd + 1), macro[1]);
        }
        else {
            overload = new TexStyleDefine([], macro.slice(2), macro[1]);
        }
        return new Define([overload]);
    }
}
function produce(tokens, start, end, replacements, production) {
    const splice = [];
    let overflow = [];
    let line = splice;
    for (const tok of production) {
        if (tok.token === 'ident') {
            const param = replacements.get(tok.str);
            if (param) {
                line.push(...param);
                continue;
            }
        }
        else if (Token.eq(tok, Token.DOT_EOL)) {
            overflow.push(line = []);
            continue;
        }
        const source = tok.source && tokens[0].source ?
            { ...tok.source, parent: tokens[0].source } :
            tok.source || tokens[0].source;
        line.push(source ? { ...tok, source } : tok);
    }
    overflow = overflow.filter(l => l.length);
    if (overflow.length && end < tokens.length) {
        return 'cannot expand .eol without consuming to end of line';
    }
    tokens.splice(start, end - start, ...splice);
    return overflow;
}
class CStyleDefine {
    constructor(params, production, definition) {
        this.params = params;
        this.production = production;
        this.definition = definition;
    }
    expand(tokens, start) {
        let i = start + 1;
        let splice = this.params.length ? tokens.length : start;
        let end = splice;
        const replacements = new Map();
        if (start < tokens.length && Token.eq(Token.LP, tokens[i])) {
            end = Token.findBalanced(tokens, i);
            if (end < 0) {
                return 'missing close paren for enclosed C-style expansion';
            }
            splice = end + 1;
            i++;
        }
        const args = Token.parseArgList(tokens, i, end);
        if (args.length > this.params.length) {
            return 'too many args';
        }
        for (i = 0; i < this.params.length; i++) {
            let arg = args[i] || [];
            const front = arg[0];
            if (arg.length === 1 && front.token === 'grp') {
                arg = front.inner;
            }
            replacements.set(this.params[i], arg);
        }
        return produce(tokens, start, splice, replacements, this.production);
    }
    canOverload() { return Boolean(this.params.length); }
}
class TexStyleDefine {
    constructor(pattern, production, definition) {
        this.pattern = pattern;
        this.production = production;
        this.definition = definition;
    }
    expand(tokens, start) {
        let i = start + 1;
        const replacements = new Map();
        for (let patPos = 0; patPos < this.pattern.length; patPos++) {
            const pat = this.pattern[patPos];
            if (pat.token === 'ident') {
                const delim = this.pattern[patPos + 1];
                if (!delim || (delim === null || delim === void 0 ? void 0 : delim.token) === 'ident') {
                    const tok = tokens[i++];
                    if (!tok)
                        return `missing undelimited argument ${Token.name(pat)}`;
                    replacements.set(pat.str, tok.token === 'grp' ? tok.inner : [tok]);
                }
                else {
                    const end = Token.eq(delim, Token.DOT_EOL) ?
                        tokens.length : Token.find(tokens, delim, i);
                    if (end < 0)
                        return `could not find delimiter ${Token.name(delim)}`;
                    replacements.set(pat.str, tokens.slice(i, end));
                    i = end;
                }
            }
            else if (Token.eq(pat, Token.DOT_EOL)) {
                if (i < tokens.length)
                    return `could not match .eol`;
            }
            else {
                if (!Token.eq(tokens[i++], pat)) {
                    return `could not match: ${Token.name(pat)}`;
                }
            }
        }
        return produce(tokens, start, i, replacements, this.production);
    }
    canOverload() { return Boolean(this.pattern.length); }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmaW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2pzL2FzbS9kZWZpbmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLEtBQUssRUFBQyxNQUFNLFlBQVksQ0FBQztBQUVqQyxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUM7QUFFcEIsTUFBTSxPQUFPLE1BQU07SUFDakIsWUFBcUMsU0FBMkI7UUFBM0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7SUFBRyxDQUFDO0lBU3BFLFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDakUsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFjO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUU7WUFDdkIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7WUFDckUsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDNUMsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztZQUN2RCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztZQUMvQyxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNsRCxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixJQUFJLEdBQUcs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R0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztvQkFDaEQsQ0FBQyxHQUFHLEdBQUcsQ0FBQztpQkFDVDthQUNGO2lCQUFNLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUN2QyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTTtvQkFBRSxPQUFPLHNCQUFzQixDQUFDO2FBQ3REO2lCQUFNO2dCQUVMLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFO29CQUMvQixPQUFPLG9CQUFvQixLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7aUJBQzlDO2FBQ0Y7U0FDRjtRQUVELE9BQU8sT0FBTyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLFlBQVksRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVELFdBQVcsS0FBSyxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN2RCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7VG9rZW59IGZyb20gJy4vdG9rZW4uanMnO1xuXG5jb25zdCBERUJVRyA9IGZhbHNlO1xuXG5leHBvcnQgY2xhc3MgRGVmaW5lIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IG92ZXJsb2FkczogRGVmaW5lT3ZlcmxvYWRbXSkge31cblxuICAvLyBvdmVycmlkZShtYWNybzogTWFjcm9FeHBhbnNpb24pOiBNYWNyb0V4cGFuc2lvbiB7XG4gIC8vICAgaWYgKG1hY3JvIGluc3RhbmNlb2YgRGVmaW5lKSB7XG4gIC8vICAgICByZXR1cm4gbmV3IERlZmluZShbLi4udGhpcy5vdmVybG9hZHMsIC4uLm1hY3JvLm92ZXJsb2Fkc10pO1xuICAvLyAgIH1cbiAgLy8gICByZXR1cm4gbWFjcm87XG4gIC8vIH1cblxuICBjYW5PdmVybG9hZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybG9hZHNbdGhpcy5vdmVybG9hZHMubGVuZ3RoIC0gMV0uY2FuT3ZlcmxvYWQoKTtcbiAgfVxuXG4gIGFwcGVuZChkZWZpbmU6IERlZmluZSkge1xuICAgIGlmICghdGhpcy5jYW5PdmVybG9hZCgpKSB7XG4gICAgICBjb25zdCBwcmV2RGVmID0gdGhpcy5vdmVybG9hZHNbdGhpcy5vdmVybG9hZHMubGVuZ3RoIC0gMV0uZGVmaW5pdGlvbjtcbiAgICAgIGNvbnN0IGF0ID0gcHJldkRlZiA/IFRva2VuLmF0KHByZXZEZWYpIDogJyc7XG4gICAgICBjb25zdCBwcmV2ID0gYXQucmVwbGFjZSgvYXQvLCAncHJldmlvdXNseSBkZWZpbmVkIGF0Jyk7XG4gICAgICBjb25zdCBuZXh0RGVmID0gZGVmaW5lLm92ZXJsb2Fkc1swXS5kZWZpbml0aW9uO1xuICAgICAgY29uc3QgbmV4dCA9IG5leHREZWYgPyBUb2tlbi5uYW1lQXQobmV4dERlZikgOiAnJztcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLW92ZXJsb2FkYWJsZTogJHtuZXh0fSR7cHJldn1gKTtcbiAgICB9XG4gICAgdGhpcy5vdmVybG9hZHMucHVzaCguLi5kZWZpbmUub3ZlcmxvYWRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBhbmRzIGluIHBsYWNlLCBwb3NzaWJseSBpbiB0aGUgbWlkZGxlIG9mIGEgbGluZSEgIFJldHVybnMgdHJ1ZVxuICAgKiBpZiBzdWNjZXNzZnVsLiAgT3RoZXJ3aXNlIHJldHVybiBmYWxzZSBhbmQgZG8gbm90aGluZy5cbiAgICovXG4gIGV4cGFuZCh0b2tlbnM6IFRva2VuW10sIHN0YXJ0OiBudW1iZXIpOiBUb2tlbltdW118dW5kZWZpbmVkIHtcbiAgICBjb25zdCByZWFzb25zID0gW107XG4gICAgZm9yIChjb25zdCBvdmVybG9hZCBvZiB0aGlzLm92ZXJsb2Fkcykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gb3ZlcmxvYWQuZXhwYW5kKHRva2Vucywgc3RhcnQpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJlYXNvbnMucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoREVCVUcpIGNvbnNvbGUuZXJyb3IocmVhc29ucy5qb2luKCdcXG4nKSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIE5PVEU6IG1hY3JvWzBdIGlzIC5kZWZpbmVcbiAgc3RhdGljIGZyb20obWFjcm86IFRva2VuW10pIHtcbiAgICBpZiAoIVRva2VuLmVxKG1hY3JvWzBdLCBUb2tlbi5ERUZJTkUpKSB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWRgKTtcbiAgICBpZiAobWFjcm9bMV0/LnRva2VuICE9PSAnaWRlbnQnKSB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWRgKTtcbiAgICAvLyBwYXJzZSB0aGUgcGFyYW1ldGVyIGxpc3QsIGlmIGFueVxuICAgIGNvbnN0IHBhcmFtU3RhcnQgPSBtYWNyb1syXTtcbiAgICBsZXQgb3ZlcmxvYWQ6IERlZmluZU92ZXJsb2FkO1xuICAgIGlmICghcGFyYW1TdGFydCkge1xuICAgICAgLy8gYmxhbmsgbWFjcm9cbiAgICAgIG92ZXJsb2FkID0gbmV3IFRleFN0eWxlRGVmaW5lKFtdLCBbXSwgbWFjcm9bMV0pO1xuICAgIH0gZWxzZSBpZiAocGFyYW1TdGFydC50b2tlbiA9PT0gJ2dycCcpIHtcbiAgICAgIC8vIFRlWC1zdHlsZSBwYXJhbSBsaXN0XG4gICAgICBvdmVybG9hZCA9IG5ldyBUZXhTdHlsZURlZmluZShwYXJhbVN0YXJ0LmlubmVyLCBtYWNyby5zbGljZSgzKSwgbWFjcm9bMV0pO1xuICAgIH0gZWxzZSBpZiAocGFyYW1TdGFydC50b2tlbiA9PT0gJ2xwJykge1xuICAgICAgLy8gQy1zdHlsZSBwYXJhbSBsaXN0XG4gICAgICBjb25zdCBwYXJhbUVuZCA9IFRva2VuLmZpbmRCYWxhbmNlZChtYWNybywgMik7XG4gICAgICBpZiAocGFyYW1FbmQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgY2xvc2UgcGFyZW4gJHtUb2tlbi5uYW1lQXQobWFjcm9bMl0pfWApO1xuICAgICAgfVxuICAgICAgb3ZlcmxvYWQgPVxuICAgICAgICAgIG5ldyBDU3R5bGVEZWZpbmUoVG9rZW4uaWRlbnRzRnJvbUNMaXN0KG1hY3JvLnNsaWNlKDMsIHBhcmFtRW5kKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtYWNyby5zbGljZShwYXJhbUVuZCArIDEpLCBtYWNyb1sxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIHBhcmFtIGxpc3RcbiAgICAgIG92ZXJsb2FkID0gbmV3IFRleFN0eWxlRGVmaW5lKFtdLCBtYWNyby5zbGljZSgyKSwgbWFjcm9bMV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERlZmluZShbb3ZlcmxvYWRdKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgRGVmaW5lT3ZlcmxvYWQge1xuICByZWFkb25seSBkZWZpbml0aW9uPzogVG9rZW47XG4gIGV4cGFuZCh0b2tlbnM6IFRva2VuW10sIHN0YXJ0OiBudW1iZXIpOiBzdHJpbmd8VG9rZW5bXVtdO1xuICBjYW5PdmVybG9hZCgpOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiBwcm9kdWNlKHRva2VuczogVG9rZW5bXSxcbiAgICAgICAgICAgICAgICAgc3RhcnQ6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgZW5kOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50czogTWFwPHN0cmluZywgVG9rZW5bXT4sXG4gICAgICAgICAgICAgICAgIHByb2R1Y3Rpb246IFRva2VuW10pOiBzdHJpbmd8VG9rZW5bXVtdIHtcbiAgY29uc3Qgc3BsaWNlOiBUb2tlbltdID0gW107XG4gIGxldCBvdmVyZmxvdzogVG9rZW5bXVtdID0gW107XG4gIGxldCBsaW5lID0gc3BsaWNlO1xuICBmb3IgKGNvbnN0IHRvayBvZiBwcm9kdWN0aW9uKSB7XG4gICAgaWYgKHRvay50b2tlbiA9PT0gJ2lkZW50Jykge1xuICAgICAgY29uc3QgcGFyYW0gPSByZXBsYWNlbWVudHMuZ2V0KHRvay5zdHIpO1xuICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYWN0dWFsbHkgYSBwYXJhbWV0ZXJcbiAgICAgICAgbGluZS5wdXNoKC4uLnBhcmFtKTsgLy8gVE9ETyAtIGNvcHkgdy8gY2hpbGQgc291cmNlaW5mbz9cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChUb2tlbi5lcSh0b2ssIFRva2VuLkRPVF9FT0wpKSB7XG4gICAgICBvdmVyZmxvdy5wdXNoKGxpbmUgPSBbXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID1cbiAgICAgICAgdG9rLnNvdXJjZSAmJiB0b2tlbnNbMF0uc291cmNlID9cbiAgICAgICAgICAgIHsuLi50b2suc291cmNlLCBwYXJlbnQ6IHRva2Vuc1swXS5zb3VyY2V9IDpcbiAgICAgICAgICAgIHRvay5zb3VyY2UgfHwgdG9rZW5zWzBdLnNvdXJjZTtcbiAgICBsaW5lLnB1c2goc291cmNlID8gey4uLnRvaywgc291cmNlfSA6IHRvayk7XG4gIH1cbiAgb3ZlcmZsb3cgPSBvdmVyZmxvdy5maWx0ZXIobCA9PiBsLmxlbmd0aCk7XG4gIGlmIChvdmVyZmxvdy5sZW5ndGggJiYgZW5kIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgIHJldHVybiAnY2Fubm90IGV4cGFuZCAuZW9sIHdpdGhvdXQgY29uc3VtaW5nIHRvIGVuZCBvZiBsaW5lJztcbiAgfVxuICB0b2tlbnMuc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCwgLi4uc3BsaWNlKTtcbiAgcmV0dXJuIG92ZXJmbG93O1xufVxuXG5jbGFzcyBDU3R5bGVEZWZpbmUgaW1wbGVtZW50cyBEZWZpbmVPdmVybG9hZCB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHBhcmFtczogc3RyaW5nW10sXG4gICAgICAgICAgICAgIHJlYWRvbmx5IHByb2R1Y3Rpb246IFRva2VuW10sXG4gICAgICAgICAgICAgIHJlYWRvbmx5IGRlZmluaXRpb24/OiBUb2tlbikge31cblxuICBleHBhbmQodG9rZW5zOiBUb2tlbltdLCBzdGFydDogbnVtYmVyKTogc3RyaW5nfFRva2VuW11bXSB7XG4gICAgbGV0IGkgPSBzdGFydCArIDE7IC8vIHNraXAgcGFzdCB0aGUgbWFjcm8gY2FsbCBpZGVudGlmaWVyXG4gICAgbGV0IHNwbGljZSA9IHRoaXMucGFyYW1zLmxlbmd0aCA/IHRva2Vucy5sZW5ndGggOiBzdGFydDtcbiAgICBsZXQgZW5kID0gc3BsaWNlO1xuICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBUb2tlbltdPigpO1xuICAgIFxuICAgIGlmIChzdGFydCA8IHRva2Vucy5sZW5ndGggJiYgVG9rZW4uZXEoVG9rZW4uTFAsIHRva2Vuc1tpXSkpIHtcbiAgICAgIGVuZCA9IFRva2VuLmZpbmRCYWxhbmNlZCh0b2tlbnMsIGkpO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgLy8gdGhyb3c/XG4gICAgICAgIHJldHVybiAnbWlzc2luZyBjbG9zZSBwYXJlbiBmb3IgZW5jbG9zZWQgQy1zdHlsZSBleHBhbnNpb24nO1xuICAgICAgfVxuICAgICAgc3BsaWNlID0gZW5kICsgMTtcbiAgICAgIGkrKztcbiAgICAgIC8vdG9rID0gbmV3IFNjYW5uZXIodG9rZW5zLnNsaWNlKDAsIGkpLCBzdGFydCArIDEpO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgY29tbWEsIHNraXBwaW5nIGJhbGFuY2VkIHBhcmVucy5cbiAgICBjb25zdCBhcmdzID0gVG9rZW4ucGFyc2VBcmdMaXN0KHRva2VucywgaSwgZW5kKTtcbiAgICBpZiAoYXJncy5sZW5ndGggPiB0aGlzLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAndG9vIG1hbnkgYXJncyc7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYXJnID0gYXJnc1tpXSB8fCBbXTtcbiAgICAgIGNvbnN0IGZyb250ID0gYXJnWzBdO1xuICAgICAgaWYgKGFyZy5sZW5ndGggPT09IDEgJiYgZnJvbnQudG9rZW4gPT09ICdncnAnKSB7XG4gICAgICAgIGFyZyA9IGZyb250LmlubmVyO1xuICAgICAgfVxuICAgICAgcmVwbGFjZW1lbnRzLnNldCh0aGlzLnBhcmFtc1tpXSwgYXJnKTtcbiAgICB9XG4gICAgLy8gQWxsIHBhcmFtcyBmaWxsZWQgaW4sIG1ha2UgcmVwbGFjZW1lbnQgYW5kIGZpbGwgaXQgaW4uXG4gICAgcmV0dXJuIHByb2R1Y2UodG9rZW5zLCBzdGFydCwgc3BsaWNlLCByZXBsYWNlbWVudHMsIHRoaXMucHJvZHVjdGlvbik7XG4gIH1cblxuICBjYW5PdmVybG9hZCgpIHsgcmV0dXJuIEJvb2xlYW4odGhpcy5wYXJhbXMubGVuZ3RoKTsgfVxufVxuXG5jbGFzcyBUZXhTdHlsZURlZmluZSBpbXBsZW1lbnRzIERlZmluZU92ZXJsb2FkIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgcGF0dGVybjogVG9rZW5bXSxcbiAgICAgICAgICAgICAgcmVhZG9ubHkgcHJvZHVjdGlvbjogVG9rZW5bXSxcbiAgICAgICAgICAgICAgcmVhZG9ubHkgZGVmaW5pdGlvbj86IFRva2VuKSB7fVxuICBleHBhbmQodG9rZW5zOiBUb2tlbltdLCBzdGFydDogbnVtYmVyKTogc3RyaW5nfFRva2VuW11bXSB7XG4gICAgbGV0IGkgPSBzdGFydCArIDE7IC8vIHNraXAgcGFzdCB0aGUgbWFjcm8gY2FsbCBpZGVudGlmaWVyXG4gICAgY29uc3QgcmVwbGFjZW1lbnRzID0gbmV3IE1hcDxzdHJpbmcsIFRva2VuW10+KCk7XG4gICAgZm9yIChsZXQgcGF0UG9zID0gMDsgcGF0UG9zIDwgdGhpcy5wYXR0ZXJuLmxlbmd0aDsgcGF0UG9zKyspIHtcbiAgICAgIGNvbnN0IHBhdCA9IHRoaXMucGF0dGVybltwYXRQb3NdO1xuICAgICAgaWYgKHBhdC50b2tlbiA9PT0gJ2lkZW50Jykge1xuICAgICAgICBjb25zdCBkZWxpbSA9IHRoaXMucGF0dGVybltwYXRQb3MgKyAxXTtcbiAgICAgICAgaWYgKCFkZWxpbSB8fCBkZWxpbT8udG9rZW4gPT09ICdpZGVudCcpIHtcbiAgICAgICAgICAvLyBwYXJzZSB1bmRlbGltaXRlZFxuICAgICAgICAgIGNvbnN0IHRvayA9IHRva2Vuc1tpKytdO1xuICAgICAgICAgIGlmICghdG9rKSByZXR1cm4gYG1pc3NpbmcgdW5kZWxpbWl0ZWQgYXJndW1lbnQgJHtUb2tlbi5uYW1lKHBhdCl9YDtcbiAgICAgICAgICByZXBsYWNlbWVudHMuc2V0KHBhdC5zdHIsIHRvay50b2tlbiA9PT0gJ2dycCcgPyB0b2suaW5uZXIgOiBbdG9rXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcGFyc2UgZGVsaW1pdGVkXG4gICAgICAgICAgY29uc3QgZW5kID0gVG9rZW4uZXEoZGVsaW0sIFRva2VuLkRPVF9FT0wpID9cbiAgICAgICAgICAgICAgdG9rZW5zLmxlbmd0aCA6IFRva2VuLmZpbmQodG9rZW5zLCBkZWxpbSwgaSk7XG4gICAgICAgICAgaWYgKGVuZCA8IDApIHJldHVybiBgY291bGQgbm90IGZpbmQgZGVsaW1pdGVyICR7VG9rZW4ubmFtZShkZWxpbSl9YDtcbiAgICAgICAgICAvL3BhdFBvcysrO1xuICAgICAgICAgIHJlcGxhY2VtZW50cy5zZXQocGF0LnN0ciwgdG9rZW5zLnNsaWNlKGksIGVuZCkpO1xuICAgICAgICAgIGkgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoVG9rZW4uZXEocGF0LCBUb2tlbi5ET1RfRU9MKSkge1xuICAgICAgICBpZiAoaSA8IHRva2Vucy5sZW5ndGgpIHJldHVybiBgY291bGQgbm90IG1hdGNoIC5lb2xgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdG9rZW4gdG8gbWF0Y2hcbiAgICAgICAgaWYgKCFUb2tlbi5lcSh0b2tlbnNbaSsrXSwgcGF0KSkge1xuICAgICAgICAgIHJldHVybiBgY291bGQgbm90IG1hdGNoOiAke1Rva2VuLm5hbWUocGF0KX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vdyBzcGxpY2UgaW4gdGhlIHByb2R1Y3Rpb24gYW5kIGZpbGwgdG8gZW5kIG9mIGxpbmUgXG4gICAgcmV0dXJuIHByb2R1Y2UodG9rZW5zLCBzdGFydCwgaSwgcmVwbGFjZW1lbnRzLCB0aGlzLnByb2R1Y3Rpb24pO1xuICB9XG5cbiAgY2FuT3ZlcmxvYWQoKSB7IHJldHVybiBCb29sZWFuKHRoaXMucGF0dGVybi5sZW5ndGgpOyB9XG59XG5cblxuLy8gY2E2NSBiZWhhdmlvclxuLy8gIC0gZXhwYW5kIG1hY3JvcyBpbiBhcmd1bWVudHMgYmVmb3JlIHNlbmRpbmcgdGhlbSBpbnRvIG91dGVyIG1hY3JvXG4vLyAgLSBkb24ndCBleHBhbmQgbWFjcm9zIGluIHByb2R1Y3Rpb25cbi8vICAtIG5lc3RlZCBicmFjZXMgZ28gYXdheSBiZWNhdXNlIGV4cGFuc2lvbiBoYXBwZW5zIHdoaWxlIGxvb2tpbmcgZm9yIGNsb3NpbmcgYnJhY2Vcbi8vICAtIHdoZW4gc2Nhbm5pbmcgZm9yIGFyZ3VtZW50cywgY29tbWEgdGVybWluYXRlcywgc29cbi8vICAgICBBQShhMSwgYTIpIC0+IGExLCBhMiwgYTEsIGEyXG4vLyAgICAgQUEgMSwgMiwgMyAtLS0+IDEsIDIsIDEsIDIsIDNcbi8vICAgIGJ1dFxuLy8gICAgIEFBIHsxLCAyfSwgMyAgZG9lc24ndCBzZWVtIHRvIGV4cGFuZCB0byAgMSwgMiwgMywgMSwgMiwgMyAgPz8/XG4vLyAgLSBzcGFjZSBiZWZvcmUgcGFyZW4gaW4gZGVmbiBkb2Vzbid0IGNoYW5nZSBhbnl0aGluZ1xuXG5cbi8vIGZ1bmN0aW9uIGZhaWwodDogVG9rZW4sIG1zZzogc3RyaW5nKTogbmV2ZXIge1xuLy8gICBsZXQgcyA9IHQuc291cmNlO1xuLy8gICBpZiAocykgbXNnICs9IGBcXG4gIGF0ICR7cy5maWxlfToke3MubGluZX06JHtzLmNvbHVtbn06ICR7cy5jb250ZW50fWA7XG4vLyAgIHdoaWxlIChzPy5wYXJlbnQpIHtcbi8vICAgICBzID0gcy5wYXJlbnQ7XG4vLyAgICAgbXNnICs9IGBcXG4gIGluY2x1ZGVkIGZyb20gJHtzLmZpbGV9OiR7cy5saW5lfToke3MuY29sdW1ufTogJHtzLmNvbnRlbnR9YDtcbi8vICAgfVxuLy8gICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbi8vIH1cbiJdfQ==