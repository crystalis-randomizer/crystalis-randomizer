// Try 32 directions, so dir D is theta=D*pi/16

// Tables:
//  - Sin/Cos (256 each)
//  - Fraction table (256 bits)
//  - Use 16 frames for fractions

// 32 speeds: 0.5, 0.75, ..., 8, 8.25
const speeds = Array.from({length: 32}, (_, i) => (i + 2) / 4);

// takes a numeric component, returns a byte representation with 1/16 resolution
function toComponent16(v) {
  const rounded = Math.round(v * 16);
  return rounded >>> 4 | (rounded << 4) & 0xf0;
}
// takes a numeric component, returns a byte representation with 1/8 resolution
function toComponent8(v) {
  const rounded = Math.round(v * 8);
  return rounded >>> 3 | (rounded << 5) & 0xe0;
}

class Writer {
  constructor() {
    this.buffer = [];
  }

  print(text) {
    this.flush();
    console.log(text);
  }

  push(b, ...rest) {
    this.buffer.push(b);
    if (this.buffer.length === 16) this.flush();
    if (rest.length) this.push(...rest);
  }

  flush() {
    if (!this.buffer.length) return;
    console.log(`        .byte ${this.buffer.map(x => `$${x.$}`).join(',')}`);
    this.buffer = [];
  }
}

Object.defineProperties(
  Number.prototype,
  {
    $: {
      get() {
        return (Number(this) & 0xff).toString(16).padStart(2, '0');
      },
    }
  });
const lines = ['.org $a000'];

const writer = new Writer();

writer.print(`;;; DO NOT EDIT: This file generated by compute-speed-tables.js`);
writer.print(`.ifdef _EXPAND_SPEEDS`);
writer.print(`.segment "1a", "fe", "ff"`);

// First build up the fractions tables
writer.print(`.org $8500`); // .reloc`);
writer.print(`SpeedFractionTable:`);
for (let s = 0; s < 16; s++) {
  let total = 0;
  for (let f = 0; f < 16; f++) {
    total += s
    const next = Math.trunc(total / 16);
    total -= next * 16;
    const term = next ? 0x80 : 0;
    writer.push(term);
  }
}

// Sin-cosine tables
writer.print(`.org $8600`); // .reloc`);
writer.print(`SinTable:`);
for (let i = 0; i < 16; i++) {
  if (i === 8) writer.print(`CosTable:`);
  for (let s = 2; s < 34; s++) {
    writer.push(toComponent16((s / 4) * Math.sin(i * Math.PI / 16)));
  }
}

writer.print(`.endif`);

// // Then build up the speed+direction tables
// let i = 0;
// for (const s of speeds) {
//   lines.push(`Speed_${(i++).$}: ; ${s} pixels/frame`);
//   let line = '';
//   for (let d = 0; d < 80; d++) {
//     if (d % 16) {
//       line += ',';
//     } else {
//       if (line) lines.push(line);
//       line = '        .byte ';
//     }
//     line += '$' + decompose(-s * Math.cos(Math.PI * (d % 64) / 32)).$;
//   }
//   lines.push(line);
// }

// // Finally write address tables for the speeds
// let line = 'SpeedsLo:';
// for (let i = 0; i < speeds.length; i++) {
//   line += `${i % 4 ? ',' : '\n        .byte '}<Speed_${i.$}`;
// }
// lines.push(line);
// line = 'SpeedsHi:';
// for (let i = 0; i < speeds.length; i++) {
//   line += `${i % 4 ? ',' : '\n        .byte '}>Speed_${i.$}`;
// }
// lines.push(line);

// Write lines
// console.log(lines.join('\n'));
